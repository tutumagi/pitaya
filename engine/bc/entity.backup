package bc

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync"
	"time"
	"unsafe"

	"github.com/tutumagi/pitaya/engine/aoi"
	"github.com/tutumagi/pitaya/engine/dbmgr"
	"github.com/tutumagi/pitaya/logger"
	"github.com/tutumagi/pitaya/engine/math32"
	"gitlab.gamesword.com/nut/dreamcity/game/define"
	"gitlab.gamesword.com/nut/dreamcity/pb/golang/pb"

	"github.com/golang/protobuf/proto"
	"github.com/tutumagi/pitaya"
	err "github.com/tutumagi/pitaya/errors"
	"github.com/tutumagi/pitaya/protos"
	"github.com/tutumagi/pitaya/timer"
	"gitlab.gamesword.com/nut/entitygen/attr"

	"go.uber.org/zap"
)

var (
	vec3pool = sync.Pool{
		New: func() interface{} {
			return &math32.Vector3{}
		},
	}
)

// Entity 实体
type Entity struct {
	UID string // UID 只有在是玩家连接的实体，才有UID，消息收发是靠UID来标识的
	ID  string // 实体ID，如果是玩家实体，则ID也表示角色ID
	// Data interface{}

	data *attr.StrMap

	v        interface{}
	I        IBaseEntity
	typeDesc *TypeDesc

	destroyed     bool
	destroyReason int32

	baseServerID string

	baseSpace *_BaseSpaceInfo // 在 base server 里面用此 space info
	space     *Space          // 在 cell server 里面使用此 space

	yaw float32

	Viewlayer define.ViewLayer // 视野类型
	coord     *aoi.EntityCoord
	witness   *aoi.Witness

	rawTimers map[int64]*timer.Timer

	enteringSpaceRequest *pb.EnterSpaceReq
}

// NewEntity ctor
// func NewEntity(id string, data interface{}, pos math32.Vector3) *Entity {
// 	return &Entity{
// 		ID:           id,
// 		Data:         data,
// 		pos:          pos,
// 		InterestedIn: Set{},
// 		InterestedBy: Set{},
// 	}
// }

func (e *Entity) String() string {
	if e == nil {
		return ""
	}
	// return fmt.Sprintf("<Entity>label:%s id:%s data:%+v", e.typName, e.ID, e.Data)
	name := "no typedesc"
	if e.typeDesc != nil {
		name = e.typeDesc.name
	}
	return fmt.Sprintf("<Entity>label:%s id:%s pos:%s", name, e.ID, e.coord.Position())
}

func (e *Entity) init(id string, typName string, entityInstance reflect.Value) {
	e.ID = id
	e.v = entityInstance.Interface()
	e.I = entityInstance.Interface().(IBaseEntity)

	e.typeDesc = GetTypeDesc(typName)

	e.rawTimers = make(map[int64]*timer.Timer)

	e.enteringSpaceRequest = &pb.EnterSpaceReq{}
	e.resetEnterSpaceRequest()

	// if e.typeDesc.aoiFlag.Valid() && svrConfig.curServerUseSpace {
	// if svrConfig.curServerUseSpace {
	e.coord = aoi.NewEntityNode(e)
	// }

}

func (e *Entity) resetEnterSpaceRequest() {
	e.enteringSpaceRequest.Reset()
	e.enteringSpaceRequest.FromServerID = pitaya.GetServerID()
	if e.enteringSpaceRequest.Pos == nil {
		e.enteringSpaceRequest.Pos = &pb.Vec3{X: 0, Y: 0, Z: 0}
	} else {
		e.enteringSpaceRequest.Pos.X = 0
		e.enteringSpaceRequest.Pos.Y = 0
		e.enteringSpaceRequest.Pos.Z = 0
	}
}

// AttrChangedFromBytes 只会在 cellapp 调用
func (e *Entity) AttrChangedFromBytes(attrBytes map[string][]byte) {
	if len(attrBytes) == 0 {
		return
	}
	e.unmarshalChangedKey(attrBytes)
	e.attrChanged()
}

func (e *Entity) attrChanged() {
	if !e.data.HasChange() {
		return
	}
	logger.Debugf("attr change label:%s id:%s %v", e.typeDesc.name, e.ID, e.data.ChangeKey())
	var cellkeys map[string]struct{} = map[string]struct{}{}
	// var basekeys []string = []string{}
	for k := range e.data.ChangeKey() {
		f := e.typeDesc.meta.GetDef(k)
		if f.HasCell() {
			cellkeys[k] = struct{}{}
		}
		// if f.HasCell() {
		// 	basekeys = append(basekeys, k)
		// }
	}

	if len(cellkeys) > 0 {
		if CurServerUseSpace() { //  在 cellapp
			e.I.CellAttrChanged(cellkeys)
		} else { // 在其他app
			if !e.SpaceCreated() {
				return
			}

			changeKeyBytes := e.marshalChangedKey(cellkeys)
			req := &pb.EntityUpdate{
				Id:    e.ID,
				Label: e.typeDesc.name,
				Attrs: changeKeyBytes,
			}

			erro := pitaya.SendTo(context.TODO(), e.SpaceServerID(), "cellremote.updateattr", req)
			if erro != nil {
				logger.Warn("send to cellapp update attr err", zap.String("entity", e.String()), zap.Error(erro))
			}
		}
	}

	// 处理完 数据变化key回调，和db操作后，清理掉变化key
	e.data.ClearChangeKey()
}

func (e *Entity) marshalChangedKey(keys map[string]struct{}) map[string][]byte {
	ret := map[string][]byte{}
	for k := range keys {
		val := e.data.Value(k)
		bb, erro := json.Marshal(val)
		if erro != nil {
			logger.Warn("cell attr change marshal key error",
				zap.String("entity", e.String()),
				zap.String("key", k),
				zap.Any("val", val),
				zap.Error(erro))
			continue
		}
		logger.Debug("cell attr change marshal key",
			zap.String("entity", e.String()),
			zap.String("key", k),
			zap.Any("val", val),
			zap.Any("bytes", bb))

		ret[k] = bb
	}

	return ret
}

func (e *Entity) unmarshalChangedKey(changeAttrBytes map[string][]byte) {
	for k, bb := range changeAttrBytes {
		def := e.typeDesc.meta.GetDef(k)
		if def == nil {
			logger.Warn("cell attr change but not have the key def continue",
				zap.String("entity", e.String()),
				zap.String("key", k),
			)
			continue
		}
		if def.IsPrimary() {
			newV, erro := def.UnmarshalPrimary(bb)
			if erro != nil {
				logger.Warn("cell attr change unmarshal primary key error",
					zap.String("entity", e.String()),
					zap.String("key", k),
					zap.Any("val", newV),
					zap.Error(erro),
				)
				continue
			}
			e.data.Set(k, newV)
		} else {
			// TODO 这里每次都会分配内存，会有 gc 问题，这里考虑看怎么处理，能否可以跟上面的条件分支一样。
			// 使用 e.data.attrs 里面已经有 的值来 Unmarshal
			var a = reflect.New(def.P()).Interface()
			// var a = e.data.Value(k)
			erro := json.Unmarshal(bb, &a)
			if erro != nil {
				logger.Warn("cell attr change unmarshal not primary key error",
					zap.String("entity", e.String()),
					zap.String("key", k),
					// zap.Any("val", val),
					zap.Error(erro),
				)
				continue
			}
			val := reflect.ValueOf(a).Elem().Interface()
			e.data.Set(k, val)
		}

	}
}

/************************ Getter/Setter *************************/
func (e *Entity) Data() *attr.StrMap {
	return e.data
}

// TODO 理论上不应该暴露这个方法
func (e *Entity) SetBaseSpaceInfo(id string, kind int32, serverID string) {
	e.baseSpace = newBaseSpaceInfo(id, kind, serverID)
}

// BaseServerID 返回baseappId
func (e *Entity) BaseServerID() string {
	return e.baseServerID
}

func (e *Entity) SetBaseServerID(id string) {
	e.baseServerID = id
}

// Space 返回space，只有在 cell server 才允许访问此方法
func (e *Entity) Space() *Space {
	return e.space
}

// SpaceServerID 返回实体所在space的serverID
func (e *Entity) SpaceServerID() string {
	if svrConfig.curServerUseSpace {
		return pitaya.GetServerID()
	} else {
		return e.baseSpace.ServerID
	}
}

// SpaceID 返回实体所在的spaceID
func (e *Entity) SpaceID() string {
	if !e.SpaceCreated() {
		return ""
	}
	if svrConfig.curServerUseSpace {
		return e.space.SpaceID()
	} else {
		return e.baseSpace.ID
	}
}

// SpaceKind 返回实体所在的spaceKind
func (e *Entity) SpaceKind() int32 {
	if !e.SpaceCreated() {
		return define.NilSpaceKind
	}
	if svrConfig.curServerUseSpace {
		return e.space.Kind()
	} else {
		return e.baseSpace.Kind
	}
}

// SpaceCreated 实体是否已经在space创建了，只有这里返回true，spaceID和spaceKind 才有合法的值
func (e *Entity) SpaceCreated() bool {
	if svrConfig.curServerUseSpace {
		return e.space != nil
	} else {
		return e.baseSpace != nil
	}
}

// GetPosition get pos
func (e *Entity) GetPosition() *math32.Vector3 {
	return e.coord.Position()
}

// GetYaw get yaw
func (e *Entity) GetYaw() float32 {
	return e.yaw
}

// StopMove 停止移动
func (e *Entity) StopMove(pos math32.Vector3, yaw float32) {
	// vec3 := vec3pool.Get().(*math32.Vector3)
	// vec3.X = pos.X
	// vec3.Y = pos.Y
	// vec3.Z = pos.Z

	// e.setPosition(vec3, yaw)

	// e.I.OnStopMove(vec3, yaw)

	// vec3pool.Put(vec3)

	e.setPosition(&pos, yaw)
	e.I.OnStopMove(&pos, yaw)
}

func (e *Entity) NotifyCellMove(pos *math32.Vector3, yaw float32) {
	if !e.SpaceCreated() {
		return
	}
	spaceServerID := e.SpaceServerID()

	msg := &pb.SyncPos{
		Id:    e.ID,
		Label: e.TypName(),
		Cur: &pb.Vec3{
			X: pos.X,
			Y: pos.Y,
			Z: pos.Z,
		},
		Yaw: yaw,
	}
	if err := pitaya.SendTo(
		context.TODO(),
		spaceServerID,
		"cellapp.spaceremote.syncpos",
		msg,
	); err != nil {
		logger.Errorf("e:%s syncpos rpc error %s", e.String(), err)
	}
}

// Move set pos
func (e *Entity) Move(pos math32.Vector3) {
	// vec3 := vec3pool.Get().(*math32.Vector3)
	// vec3.X = pos.X
	// vec3.Y = pos.Y
	// vec3.Z = pos.Z

	// e.setPosition(vec3, e.yaw)

	// e.I.OnPositionChanged(vec3)
	// vec3pool.Put(vec3)

	e.setPosition(&pos, e.yaw)
	e.I.OnPositionYawChanged(&pos, e.yaw)
}

// Rot 设置朝向,yaw 绕Y轴旋转弧度
func (e *Entity) Rot(yaw float32) {
	// e.setPosition(nil, yaw)

	// e.I.OnYawChanged(yaw)

	e.setPosition(nil, yaw)
	e.I.OnPositionYawChanged(e.coord.Position(), yaw)
}

// MoveAndRot set pos & yaw
func (e *Entity) MoveAndRot(pos math32.Vector3, yaw float32) {
	e.setPosition(&pos, yaw)
	e.I.OnPositionYawChanged(&pos, yaw)
}

func (e *Entity) setPosition(pos *math32.Vector3, yaw float32) {
	space := e.space
	if space == nil {
		logger.Errorf("%s setPosition %s. space is nil", e, pos)
		return
	}
	if pos != nil {
		space.move(e, pos)
	} else {
		// pos = e.coord.Position()
	}
	e.yaw = yaw
}

// IsUseAOI 该实体是否开启AOI
func (e *Entity) IsUseAOI() bool {
	return e.typeDesc.useAOI
}

// TypName 该实体的类别
func (e *Entity) TypName() string {
	return e.typeDesc.name
}

// IsSpaceEntity 此实体是否是空间
func (e *Entity) IsSpaceEntity() bool {
	return strings.Contains(e.typeDesc.name, _SpaceEntityType)
}

// AsSpace 类型转换为space
func (e *Entity) AsSpace() *Space {
	if !e.IsSpaceEntity() {
		logger.Panicf("%s is not a space", e)
	}

	return (*Space)(unsafe.Pointer(e))
}

// Val 返回实际用户定义的 实体interface
//	 使用方式：landEntity := e.Val().(*LandEntity)
func (e *Entity) Val() interface{} {
	return e.v
}

func (e *Entity) DestroyReason() int32 {
	return e.destroyReason
}

/************************ IEntity interface default imp ***********************/

// OnInit IEntity 的接口，构造完成后回调
func (e *Entity) OnInit() error {
	return nil
}

// OnCreated IEntity 的接口，构造完成，初始化数据后会回调
func (e *Entity) OnCreated() {}

// OnDestroy IEntity的接口，销毁时回调
func (e *Entity) OnDestroy() {}

// OnMigrateOut 实体迁移出去后
func (e *Entity) OnMigrateOut() {}

// OnMigrateIn 实体迁移进来后
func (e *Entity) OnMigrateIn() {}

// EnterSpaceFailed 实体进入场景失败了 在业务 app 触发
func (e *Entity) EnterSpaceFailed(error) {}

// EnterSpaceFailed 实体进入场景失败了 在业务 app 触发
func (e *Entity) EnterSpaceSuccess(spaceID string, spaceKind int32) {}

// BeforeEnterSpace IEntity的接口，进入场景前回调
func (e *Entity) BeforeEnterSpace() {}

// AfterEnterSpace IEntity的接口，进入场景后回调
func (e *Entity) AfterEnterSpace() {}

// OnLeaveSpace IEntity的接口，离开场景后回调
func (e *Entity) OnLeaveSpace(s *Space) {}

// OnEnterSight IEntity的接口，其他实体进入视野时回调
func (e *Entity) OnEnterSight(other *Entity) {}

// OnLeaveSight IEntity的接口，其他实体离开视野时回调
func (e *Entity) OnLeaveSight(other *Entity) {}

// DefaultPos 默认的位置，不会触发在 space中的 move api。 只会在加载/创建实体时，数据创建完成后调用
func (e *Entity) DefaultPos() math32.Vector3 {
	return math32.ZeroVec3
}

// Tick 所有实体的主循环
func (e *Entity) Tick(dt int32) {}

// OnPositionYawChanged 实体的位置和朝向发生了变化
func (e *Entity) OnPositionYawChanged(newPos *math32.Vector3, yaw float32) {}

// // OnPositionChanged 实体的位置发生了变化
// func (e *Entity) OnPositionChanged(newPos *math32.Vector3) {}

// // OnYawChanged 实体的朝向发生了变化
// func (e *Entity) OnYawChanged(yaw float32) {}

// OnStopMove 实体停止移动了
func (e *Entity) OnStopMove(newPos *math32.Vector3, yaw float32) {}

/************************** AOI ***************************/

// AoiID string return aoi id
func (e *Entity) AoiID() string {
	return e.ID
}

// Coord get aoi coord
func (e *Entity) Coord() *aoi.EntityCoord {
	return e.coord
}

func (e *Entity) setWitness(w *aoi.Witness) {
	e.witness = w
	w.Attach(e)
	w.SetViewRadius(e.typeDesc.aoiRadius, 0)
}

// Witness get witness
func (e *Entity) Witness() *aoi.Witness {
	return e.witness
}

// InterestedBy return interestedBy entities
func (e *Entity) InterestedBy() map[aoi.Entityer]struct{} {
	if e.witness != nil {
		return e.witness.InterestedBy
	}
	return nil
}

// InterestIn return InterestIn entities
func (e *Entity) InterestIn() map[aoi.Entityer]struct{} {
	if e.witness != nil {
		return e.witness.InterestIn
	}
	return nil
}

// OnEnterAOI other enter my view
func (e *Entity) OnEnterAOI(other aoi.Entityer) {
	otherEntity := other.(*Entity)
	e.I.OnEnterSight(otherEntity)
}

// OnLeaveAOI other leave my view
func (e *Entity) OnLeaveAOI(other aoi.Entityer) {
	otherEntity := other.(*Entity)
	e.I.OnLeaveSight(otherEntity)
}

/************************ database **************************/

// Save to db
// Save 表示有数据变化，
func (e *Entity) Save() {
	// // TODO 考虑多并发的情况
	// if !e.data.HasChange() {
	// 	return
	// }
	// 先进行数据变化key 的处理
	e.attrChanged()

	// 在 cellapp 不用做存储DB操作
	if CurServerUseSpace() {

	} else {
		// 在其他app 需要做存储db操作
		e.saveToDB()
	}

}

func (e *Entity) saveToDB() {
	// 如果实体不用持久化，或者是在 aoi server 则return
	if !e.IsPersistent() || CurServerUseSpace() {
		return
	}

	req := dbmgr.QueryPara{
		TblName: define.EntityTableName(e.typeDesc.name),
		KeyName: "id",
		Key:     e.ID,
	}
	dbmgr.Set(req, e.GetPersistentData())
}

// IsPersistent 实体是否需要持久化
func (e *Entity) IsPersistent() bool {
	return e.typeDesc.isPersistent
}

/****************************** Destroy ******************************/

// Destroy destroy entity
func (e *Entity) Destroy(reason ...int32) {
	if e.destroyed {
		return
	}

	if e.typeDesc.name == define.TypNamePlayer {
		logger.Debugf("%s destroy...%v", e, reason)
	}

	if len(reason) > 0 {
		e.destroyReason = reason[0]
	}
	e.destroyEntity(false)

	if !CurServerUseSpace() {
		// 如果是在 base server destroy，通知对应的space 玩家离开了
		if e.SpaceCreated() {
			if erre := pitaya.SendTo(
				context.Background(),
				e.SpaceServerID(),
				"cellremote.destroyentity",
				&pb.Entity{
					Id:     e.ID,
					Label:  e.TypName(),
					Reason: e.destroyReason,
				},
			); erre != nil {
				logger.Error("leave rpc error", zap.Error(erre))
			}
		}
	}
}

// TODO 如果涉及到迁移实体的操作，这里还没做
func (e *Entity) destroyEntity(isMigrate bool) {
	if e.space != nil {
		e.space.leave(e)
	}

	if isMigrate {
		e.I.OnMigrateOut()
	} else {
		e.I.OnDestroy()
	}

	e.clearRawTimers()
	e.rawTimers = nil

	if isMigrate {
		// TODO 这里是否需要做一些处理？
	} else {
		// 如果不是迁移时的销毁，则保存一下数据
		// TODO 这里销毁时保存数据到服务器，有问题再改
		e.saveToDB()
	}

	e.destroyed = true

	entManager.del(e)
}

func (e *Entity) clearRawTimers() {
	for _, t := range e.rawTimers {
		t.Stop()
	}
	e.rawTimers = map[int64]*timer.Timer{}
}

// IsDestroyed 实体是否已销毁
func (e *Entity) IsDestroyed() bool {
	return e.destroyed
}

func (e *Entity) GetPersistentData() map[string]interface{} {
	return e.data.FilterMap(func(k string) bool {
		if def := e.typeDesc.meta.GetDef(k); def != nil {
			return def.StoreDB()
		}
		return false
	})
}

func (e *Entity) getMigrateData() map[string]interface{} {
	// return e.data.ToMap(func(k string) bool {
	// 	return true
	// })
	return e.data.ToMap()
}

func (e *Entity) getCellData() map[string]interface{} {
	var cellData = map[string]interface{}{}
	e.data.ForEach(func(k string, v interface{}) bool {
		// 应该是只发送 cell 数据给 aoi，这里先自测完成后再打开
		// def := e.typeDesc.meta.GetDef(k)
		// if def.HasCell() {
		cellData[k] = v
		// }
		return true
	})
	return cellData
}

/*************************** 切换/进入场景 *****************************/

// // GetMigratePBData 迁移逻辑
// func (e *Entity) GetMigratePBData() *pb.MigrateEntityData {
// 	databytes, _ := json.Marshal(e.getMigrateData())
// 	// pos := e.coord.Position()
// 	return &pb.MigrateEntityData{
// 		UserID:   e.UID,
// 		EntityID: e.ID,
// 		// 实体typName
// 		EntityLabel: e.typeDesc.name,
// 		// 实体序列化后的数据，目前使用json
// 		EntityDatas:  databytes,
// 		FromServerID: pitaya.GetServerID(),
// 		// 实体位置
// 		// Pos: &pb.Vec3{X: pos.X, Y: pos.Y, Z: pos.Z},
// 		// // 实体朝向
// 		// Yaw: e.yaw,
// 		// 实体所在space
// 		SpaceID:   e.SpaceID(),
// 		SpaceKind: e.SpaceKind(),
// 	}
// }

func (e *Entity) GetCellData() *pb.SEntityData {
	databytes, _ := json.Marshal(e.getCellData())
	// pos := e.coord.Position()
	return &pb.SEntityData{
		UserID:   e.UID,
		EntityID: e.ID,
		// 实体typName
		EntityLabel: e.typeDesc.name,
		// 实体序列化后的数据，目前使用json
		EntityDatas:  databytes,
		FromServerID: pitaya.GetServerID(),
		// 实体位置
		// Pos: &pb.Vec3{X: pos.X, Y: pos.Y, Z: pos.Z},
		// // 实体朝向
		// Yaw: e.yaw,
		// 实体所在space
		SpaceID:   e.SpaceID(),
		SpaceKind: e.SpaceKind(),
	}
}

// GetMigratePBData 迁移逻辑
// func (e *Entity) GetSimpleMigratePBData() *pb.MigrateEntityData {
// 	// pos := e.coord.Position()
// 	return &pb.MigrateEntityData{
// 		UserID:   e.UID,
// 		EntityID: e.ID,
// 		// 实体typName
// 		EntityLabel:  e.typeDesc.name,
// 		FromServerID: pitaya.GetServerID(),
// 		// 实体位置
// 		// Pos: &pb.Vec3{X: pos.X, Y: pos.Y, Z: pos.Z},
// 		// // 实体朝向
// 		// Yaw: e.yaw,
// 		// 实体所在space
// 		SpaceID:   e.SpaceID(),
// 		SpaceKind: e.SpaceKind(),
// 	}
// }

// PrepareEnterSpace 实体准备进入场景
func (e *Entity) PrepareEnterSpace(spaceID string, spaceKind int32, pos math32.Vector3, viewLayer int32) {
	if e.isEnteringSpace() {
		logger.Warnf("%s is entering space %s, cannot enter space %s", e, e.enteringSpaceRequest.SpaceID, spaceID)
		// e.I.OnEnterSpace()
		e.PushEnterSceneErrorIfNeed(define.ErrEnteringSpace)
		return
	}
	// 这个不会触发 positionChanged的回调
	e.coord.SetPosition(pos.X, pos.Y, pos.Z)
	// 在 cell server 上，先找下本地有没有该 space，有则直接进入，否则请求 cellmgrapp 去拿 space server id
	if svrConfig.curServerUseSpace {
		localSpace := spaceManager.getSpace(spaceID)
		if localSpace != nil {
			e.enterLocalSpace(localSpace, pos, viewLayer)
		} else {
			// TODO 这个分支还没测试到(多个cell的情况才有可能走到这里)
			e.requestMigrateTo(spaceID, spaceKind, pos, viewLayer)
		}
	} else {
		// 如果当前server 不是 空间相关的server
		e.requestMigrateTo(spaceID, spaceKind, pos, viewLayer)
	}
}

func (e *Entity) LeaveSpace() error {
	if e.isEnteringSpace() {
		logger.Warnf("%s is entering space %s, prepare cancel enter %s", e, e.enteringSpaceRequest.SpaceID, e.SpaceID())

		return define.ErrEnteringSpace
	}
	// 如果玩家不在任何一个场景里面，则返回 nil
	if !e.SpaceCreated() {
		return nil
	}

	// 在 cell server 上，先找下本地有没有该 space，有则直接进入，否则请求 cellmgrapp 去拿 space server id
	if svrConfig.curServerUseSpace {
		if e.space != nil {
			e.space.leave(e)
			e.Destroy(int32(pb.EntityLeaveReason_ELR_LEAVESPACE))
		}
		return nil
	} else {
		// 如果当前server 不是 空间相关的server
		// 请求离开场景
		err := pitaya.RPCTo(
			context.Background(),
			e.SpaceServerID(),
			"cellapp.cellremote.leavespace",
			&protos.Response{},
			&pb.Entity{
				Id:    e.ID,
				Label: e.TypName(),
			})
		if err != nil {
			logger.Errorf("%s leave space(%s) err(%s)", e, e.SpaceID(), err)
			return err
		}
		e.baseSpace = nil
		return nil
	}
}

// 进入当前进程服务中的场景
func (e *Entity) enterLocalSpace(space *Space, pos math32.Vector3, viewLayer int32) {
	logger.Debugf("e.baseId=%s, space.baseId=%s ", e.BaseServerID(), space.BaseServerID())
	if space == e.space {
		logger.Errorf("%s already in space %s", e, space)
		if e.BaseServerID() != "" && e.BaseServerID() != space.BaseServerID() {
			logger.Warnf("%s already in space %s, but 。。。", e, space)
		} else {
			e.PushEnterSceneErrorIfNeed(define.ErrAlreadyInSpace)
			return
		}
	}

	e.enteringSpaceRequest.SpaceID = space.ID
	e.enteringSpaceRequest.SpaceKind = space.kind
	e.enteringSpaceRequest.Pos.X = pos.X
	e.enteringSpaceRequest.Pos.Y = pos.Y
	e.enteringSpaceRequest.Pos.Z = pos.Z
	e.enteringSpaceRequest.Time = time.Now().UnixNano()
	e.enteringSpaceRequest.ViewLayer = viewLayer

	// 这里是将之前的进入场景的消息给取消掉
	e.cancelEnterSpace()
	if space.IsDestroyed() {
		logger.Warnf("entity enter space, but space is destroyed, enter space fail", zap.String("entity", e.String()), zap.String("space", space.String()))
		e.PushEnterSceneErrorIfNeed(define.ErrSpaceDestroyed)
		return
	}

	// 离开原来的场景
	if e.space != nil {
		e.space.leave(e)
	}

	// 这里把第一次进场景的视野参数给保存住
	e.Viewlayer = viewLayer
	// 进入现在的场景
	space.enter(e, pos)
}

func (e *Entity) cancelEnterSpace() {
	requestIsSend := e.enteringSpaceRequest.IsSend
	e.resetEnterSpaceRequest()

	if requestIsSend {
		// TODO rpc通知取消迁移
	}
}

func (e *Entity) isEnteringSpace() bool {
	now := time.Now().UnixNano()
	return now < (e.enteringSpaceRequest.Time + int64(EnterSpaceRequestTimeout))
}

func (e *Entity) requestMigrateTo(spaceID string, spaceKind int32, pos math32.Vector3, viewLayer int32) {
	e.enteringSpaceRequest.EntityID = e.ID
	e.enteringSpaceRequest.EntityLabel = e.typeDesc.name
	e.enteringSpaceRequest.SpaceID = spaceID
	e.enteringSpaceRequest.SpaceKind = spaceKind
	e.enteringSpaceRequest.Pos.X = pos.X
	e.enteringSpaceRequest.Pos.Y = pos.Y
	e.enteringSpaceRequest.Pos.Z = pos.Z
	e.enteringSpaceRequest.Time = time.Now().UnixNano()
	e.enteringSpaceRequest.ViewLayer = viewLayer

	// 请求进入场景
	err := pitaya.Send(context.Background(), "cellmgrapp.spaceservice.enterspace", e.enteringSpaceRequest)
	if err != nil {
		logger.Errorf("%s enter space(%s) err(%s)", e, spaceID, err)
		e.PushEnterSceneErrorIfNeed(define.ErrSpaceRequestFailed)
	}
}

func (e *Entity) PushEnterSceneErrorIfNeed(eee error) {
	if e.UID != "" && eee != nil {
		logger.Errorf("push enter space err. entity:%s err:%s", e, eee)
		retErr, ok := eee.(*err.Error)
		if !ok {
			retErr = define.ErrSpaceUnknown(eee)
		}
		e.PushOwnClient(define.RouterAvatarEnterScene, &pb.RspEnter{
			Code: retErr.Code,
			Msg:  retErr.Message,
		})

		if e.enteringSpaceRequest != nil {
			e.enteringSpaceRequest.Time = 0
		}
	}
}

// migrateToSpaceFromBase 迁移到另一个space，这个只会在拿到 space server id 后调用到
func (e *Entity) migrateToSpaceFromBase(spaceID string, spaceKind int32, pos math32.Vector3, spaceServerID string, viewLayer int32) {
	req := &pb.MigrateToCellReq{
		EnterSpaceID:   spaceID,
		EnterSpaceKind: spaceKind,
		EntityInfo: &pb.EntityCellInfo{
			Data:     e.GetCellData(),
			EnterPos: &pb.Vec3{X: pos.X, Y: pos.Y, Z: pos.Z},
			EnterRot: &pb.Vec3{},
		},
		ViewLayer: viewLayer,
	}
	// 通知指定的的cellapp 进行进入场景操作
	err := pitaya.SendTo(context.Background(),
		spaceServerID,
		"cellremote.enterspacefrombase",
		req,
	)
	if err != nil {
		logger.Warn("call enterspace err", zap.String("req", req.String()), zap.Error(err))
		e.PushEnterSceneErrorIfNeed(define.ErrSpaceRequestFailed)
	}

	e.resetEnterSpaceRequest()

	// 这个后面还是应该在玩家真正进入场景，就是上面那个 rpc 结束之后再赋值，才是最准确的
	e.baseSpace = &_BaseSpaceInfo{ID: spaceID, Kind: spaceKind, ServerID: spaceServerID}

}

// MigrateToSpaceFromCell 迁移到另一个space，这个只会在拿到 space server id 后调用到
func (e *Entity) MigrateToSpaceFromCell(spaceID string, spaceKind int32, pos math32.Vector3, viewLayer int32) {
	localSpace := spaceManager.getSpace(spaceID)
	if localSpace != nil {
		// 如果本地服有该场景，则直接进入该场景
		e.enterLocalSpace(localSpace, pos, viewLayer)
	} else {
		logger.Warnf("这里应该能拿到此场景，但是没有拿到",
			zap.String("spaceID", spaceID),
			zap.Int32("spaceKind", spaceKind),
			zap.Any("spaces", spaceManager.spaces))
		// TODO 这里需要通知该实体 进入场景失败
		e.PushEnterSceneErrorIfNeed(define.ErrFindSpace(spaceID))
	}
}

// 只会在业务 app 触发
func (e *Entity) enterSpaceResult(req *pb.EnterSpaceResultNotify) {
	e.resetEnterSpaceRequest()
	if req.Ok {
		logger.Info("enter space success", zap.String("msg", req.String()))

		e.baseSpace = newBaseSpaceInfo(req.SpaceID, req.SpaceKind, req.SpaceServerID)
		e.I.EnterSpaceSuccess(req.SpaceID, req.SpaceKind)
	} else {
		// TODO  目前不会跑到这个分支
		logger.Warn("enter space failed", zap.String("msg", req.String()))
		e.I.EnterSpaceFailed(err.NewError(fmt.Errorf(req.ErrMsg), req.ErrCode))
	}
}

/***************************** timer *****************************/

// AddCallback 添加timer callback
func (e *Entity) AddCallback(callback func(), interval time.Duration, count int) *timer.Timer {
	if e.rawTimers == nil {
		return nil
	}
	e.RemoveOverTimerIfHas()

	t := timer.NewTimer(callback, interval, count)
	e.rawTimers[t.ID] = t
	// logger.Infof("AddCallback. rawTimers.size = %d, uid = %s, timer.id = %d", len(e.rawTimers), e.UID, t.ID)

	return t
}

// RemoveCallback remove timer callback
func (e *Entity) RemoveCallback(t *timer.Timer) {
	t.Stop()
	delete(e.rawTimers, t.ID)
}

// 清除已完成（closed == 1）的Timer
func (e *Entity) RemoveOverTimerIfHas() {
	if e.rawTimers == nil {
		return
	}

	tmpTimers := map[int64]*timer.Timer{}
	for _, t := range e.rawTimers {
		if t.IsClose() {
			//remove it
			// logger.Infof("remove closed-timer for uid = %s, timer.id = %d", e.UID, t.ID)
		} else {
			tmpTimers[t.ID] = t
		}
	}
	e.rawTimers = tmpTimers
}

/**************************** push to client *************************/

// PushOwnClient 给当前entity的客户端推送消息
func (e *Entity) PushOwnClient(router string, msg interface{}) {
	// helper.PushToUser(router, msg, e.ID)
	if e.UID == "" {
		return
	}
	_, err := pitaya.SendPushToUsers(router, msg, []string{e.UID}, define.GateAppSvr)
	if err != nil {
		logger.Errorf("push own client(uid:%s) err:%s", e.UID, err)
	}
}

// PushNeighbourClient 给周围玩家推送消息
func (e *Entity) PushNeighbourClient(router string, msg interface{}) {
	if router == "entity.stopsyncpos" || router == "entity.syncpos" || router == "entity.syncmoveto" {

	} else {
		logger.Debugf("aoi %s %v", router, msg.(proto.Message).String())
	}

	if e.witness == nil {
		return
	}
	for entityer := range e.witness.InterestedBy {
		other := entityer.(*Entity)
		if other.typeDesc.name == define.TypNamePlayer {
			if other.UID == "" {
				logger.Warn("typename is player, but uid is empty", zap.String("entity", other.String()))
				return
			}
			_, err := pitaya.SendPushToUsers(router, msg, []string{other.UID}, define.GateAppSvr)
			if err != nil {
				logger.Errorf("push neighbour client(uid:%s) err:%s", other.UID, err)
			}
		}
	}
}

// // ma 变更的key所属的map
// //	key 变化的key
// //	val 变化的值
// func (e *Entity) sendMapAttrChangeToClients(ma *AttrMap, key string, val interface{}) {
// 	var flag AttrFlag
// 	if ma == e.data {
// 		flag = e.getAttrFlag(key)
// 	} else {
// 		// flag = ma.def.flag
// 	}

// 	if svrConfig.curServerUseSpace {
// 		// 是cellapp
// 		// TODO 需要通知周围的其他客户端
// 		if flag&afOtherClient > 0 {

// 		}
// 		// TODO 需要通知自己的客户端
// 		if flag&afClient > 0 {

// 		}
// 	} else {
// 		// 不是cellapp
// 		// TODO 需要通知到cellapp
// 		if flag&afCell > 0 {

// 		}
// 		// TODO 需要通知给周围的cellapp
// 		if flag&afOtherCell > 0 {

// 		}
// 	}
// }

// func (e *Entity) getAttrFlag(key string) AttrFlag {
// 	return e.typeDesc.attrsDef[key].flag
// }

// PushInterestin 推送 该实体 关心的实体列表消息
func (e *Entity) PushInterestin(router string, msg interface{}) {
	logger.Debugf("aoi Interestin %s %v", router, msg.(proto.Message).String())

	if e.witness == nil {
		return
	}
	for entityer := range e.witness.InterestIn {
		other := entityer.(*Entity)
		if other.typeDesc.name == define.TypNamePlayer {
			if other.UID == "" {
				logger.Warn("typename is player, but uid is empty", zap.String("entity", other.String()))
				return
			}
			pitaya.SendPushToUsers(router, msg, []string{other.UID}, define.BaseAppSrv)
		}
	}
}
